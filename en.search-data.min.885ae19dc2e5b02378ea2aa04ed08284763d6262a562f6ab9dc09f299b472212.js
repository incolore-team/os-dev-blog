'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/1.1-virtualbox-%E7%9A%84%E5%AE%89%E8%A3%85/','title':"VirtualBox 的安装",'section':"Docs",'content':"下载\r#\r\r访问 Downloads – Oracle VM VirtualBox\n找到：\n点击开始下载。\n安装\r#\r\r全部按照默认设置进行安装：\n中途若有任何“安全中心”、“杀毒软件”的提示，全部选择允许。\n结果\r#\r\r之后即可看到 VirtualBox 的主窗口：\n"});index.add({'id':1,'href':'/posts/windows-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/','title':"Windows 基础操作",'section':"Posts",'content':"Windows（Win）键在哪里\r#\r\r如何打开 PowerShell 窗口（管理员权限）\r#\r\r按下 Win+X 键。\n点击 Windows PowerShell（管理员） 菜单项，即可打开 PowerShell。\n如何打开 cmd 窗口（普通权限和管理员权限）\r#\r\r如果只需要普通权限，按下 Win+R，输入 cmd：\n然后回车（或点击 确定 ）即可：\n如果需要管理员权限，可打开 PowerShell 窗口（管理员权限），然后执行 cmd 命令：\n执行 exit 命令可退出。\n"});index.add({'id':2,'href':'/docs/1.2-%E5%9C%A8-virtualbox-%E5%AE%89%E8%A3%85-ubuntu-%E7%B3%BB%E7%BB%9F/','title':"1.2 在 Virtual Box 安装 Ubuntu 系统",'section':"Docs",'content':"在 VirtualBox 安装 Ubuntu 系统\r#\r\r访问 Index of /ubuntu-releases/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n下载\r#\r\r找到版本号最新的发行版：\n点击进入：\n找到带有 desktop（桌面版），amd64（64 位架构） 的 iso 格式下载链接。复制链接地址，用合适的工具下载：\n等待下载的过程中，可以继续后面的操作。\n创建虚拟机\r#\r\r在主界面点击【新建】：\n基本信息\r#\r\r将会显示如下窗口：\n名称：任取\n文件夹：任取，建议放在系统盘之外的磁盘，以免之后占用过多空间\n类型：选择 Linux\n版本：选择 Ubuntu (64bit)\n点击【下一步】。\n内存大小\r#\r\r内存配额建议在 1024~2048 MB 之间。建议为你的系统的内存的 1/8。你可以在任务管理器查看自己电脑的内存大小。点【下一步】。\n硬盘类型和大小\r#\r\r选择 现在创建虚拟硬盘，点击【创建】\n类型默认【VDI】，下一步。\n默认【动态分配】，下一步。\n大小可以多给一点，因为是动态分配，所以这里可以任意划分上限，建议 20~100GB。点击【创建】。\n现在虚拟机建好了。\n安装系统\r#\r\r在左边选中刚才创建的系统，点击工具栏的【启动】。\n选择启动盘\r#\r\r点击小图标：\n弹出窗口中点击【注册】，然后定位到你下载的 Ubuntu 系统文件。最后选中添加进来的文件，点击【选择】\n点击【启动】\n启动菜单\r#\r\r点进去之后，上下键移动，右 CTRL 键可以中止虚拟电脑对键盘的独占。\n我们默认选择第一项 Ubuntu，回车。\na\n上面的消息可以关掉，以免遮挡视线：\n开始安装\r#\r\r之后需要等待一阵儿，直到看到：\n点击 Install Ubuntu。\n保持默认。点击 Continue。\n取消勾选 Download updates while installing Ubuntu，点击 Continue。\n选择第一个类型。点击 Install Now。（注意：在真实电脑上安装，不要这么干，会清空你的整个硬盘！！！）\n时区，上海、重庆随便~在地图上戳一下就好啦。点击 Continue。\n设置名字，用户名，主机名等等。主机名必须是合法的域名，我这里填 localos。用户名的话，英文数字下划线组合，我这里是 pluvet。建议都小写。点击 Continue。\n之后开始正式安装。\n时间紧的话点 Skip 也可以。这里是联网下载一些文件，不是必须的。\n上面的画面表示安装完毕。按照英文提示操作，直接回车。\n安装完毕。\n个性化设置\r#\r\r你可以在桌面的右键菜单 Display Settings 中设置分辨率。\n"});index.add({'id':3,'href':'/docs/1.3-%E4%B8%BA-ubuntu-%E8%A7%A3%E9%99%A4%E7%BD%91%E7%BB%9C%E5%B0%81%E9%94%81/','title':"1.3 为 Ubuntu 解除网络封锁",'section':"Docs",'content':"为 Ubuntu 解除网络封锁\r#\r\r 外交部耿爽表示：正确地看待并维护中美在科技、人文领域的交流合作，多做有利于增进中美互信与合作的事情，要拉手而不是松手，要拆墙而不是筑墙。\n 为了避免今后遇到的各种奇葩网络问题，我们今天要先做一点微小的工作。\n创建 HTTP 局域网代理服务器\r#\r\r这一步是把我们的科学上网工具转化为一个 HTTP 代理服务器。需要得到一个 http://ip:port 形式的地址。对于 v2ray, shadowsocks, Clash, 操作有所不同。这里以 Clash 为例。如果你使用的是其它程序，请自行搜索“xxx http 局域网代理”。\n查看自己的 IP 地址\r#\r\r按下 Win+X 键。（Win 键就是能打开开始菜单那个键，在你的键盘的最底下一行，一般有个窗户的样子）\n打开 PowerShell，执行如下命令：\nPS C:\\Windows\\system32\u0026gt; ipconfig 你会看到：\nWindows IP 配置 以太网适配器 以太网: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::a5de:d926:8b89:ab0c%7 IPv4 地址 . . . . . . . . . . . . : 192.168.0.111 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 192.168.0.1 以太网适配器 VirtualBox Host-Only Network: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::5c82:dfed:f58c:b213%13 IPv4 地址 . . . . . . . . . . . . : 192.168.56.1 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 上面有两个 IPv4 地址。其中 192.168.0.111 一般是家用路由器自动分配的，会变。我们不用这一个。\n我们关注的是 VirtualBox Host-Only Network 下面这个地址：192.168.56.1 记下来。\nClash 的操作\r#\r\r首先需要下载：Releases · Fndroid/clash_for_windows_pkg (github.com)。对于 Windows（你的真机安装的系统），点击 页面中的Clash.for.Windows.Setup.xxx.exe 下载安装包。运行后看到：\n一直点下一步即可。途中杀毒软件可能会警告：\n直接允许就行。软件是开放源代码的，请不必担心。\n在软件中，切换到如下界面：\n看到上面文本框吗？里面写着 Download from a URL，把你的订阅链接复制进来，然后点 Download 按钮。等待出现新的配置文件于下方。点击使其变深色，表示已启用。\n切换到 General 界面：\nPort 处是端口。我这里由于历史遗留问题，就写成 10809，其它的也行，只要是空闲的端口。（记住这里的端口号，重要！）\n下面 Allow LAN 要启用。点一下右边的开关，绿色表示已经启用。\n现在你的代理地址\r#\r\rhttp://192.168.56.1:10809\r（上面的 IP，也即 192.168.56.1 部分，和端口，也即 10809 部分，每个人情况可能不同，请自己替换）\n（上面的字符都是英文字符，不要用中文冒号！）\n这个东西叫做 HTTP PROXY.\n你的代理设置语句\r#\r\rexport http_proxy=\u0026#34;http://192.168.56.1:10809\u0026#34; export https_proxy=\u0026#34;http://192.168.56.1:10809\u0026#34; 注意，https_proxy 对应的也是 http://192.168.56.1:10809，因为我们搭建的是 HTTP 代理服务器，而不是 HTTPS 代理服务器，后者还有一个安全加密层。\n设置 Linux 上使用代理\r#\r\r把上面这两句写入到 ~/.bashrc 文件中。\n ~ 表示的是家目录，对于 pluvet 用户而言，就是 /home/pluvet 目录。（目录就是文件夹的意思，Folder 或者 Directory。）\n~/.bashrc 文件就是 /home/pluvet/.bashrc 文件\n 写入文件的具体操作如下（使用 vi 编辑器）\n执行\npluvet@localos:~ $ vi ~/.bashrc 其中 vi 表示程序\n后面的 ~/.bashrc 表示参数，这里的参数是文件名。\n执行之后会看到：\n此时编辑器处于 命令模式，也就是你按下的键被当做命令。按下 i 键会进入编辑模式，此时你输入的内容会插入到文件中。\n在编辑模式按下 Esc 键会退出编辑模式，回到命令模式。\n 关于 vi 编辑器的更多使用方法，详见：Linux vi/vim | 菜鸟教程 (runoob.com)\n这里给出几个常用的：\n  dd 删除当前行\n  x 删除当前光标处字符\n  $ 行末\n  ^ 行首\n  h/j/k/l 左下上右移动光标\n   我们在 命令模式 按下 shift+g，或者 G，会跳转到文件的最后一行：\n\n打入 $ 命令（Shift+4），跳转到行尾：\n然后按下 a 进入编辑模式。不同之处在于按下 i 是插入（insert），a 是追加（append）。\n 如果文件被你搞乱了，就按 Esc 回到命令模式，然后按下 shift+; 也就是 :（冒号），左下角会出现一个：:，输入 q!，变成 :q!，此时按下回车，就会强制退出编辑，不保存变更。然后你可以从头再来。\n 输入一个换行符（按一下回车）：\n输入代理设置语句：\nexport http_proxy=\u0026quot;http://192.168.56.1:10809\u0026quot;\rexport https_proxy=\u0026quot;http://192.168.56.1:10809\u0026quot;\r 注：上面的语句的意思是：设置 http_proxy 环境变量的值为 http://192.168.56.1:10809，设置 https_proxy 环境变量的值为 http://192.168.56.1:10809。\n 退出编辑模式（Esc），执行 :wq （按 shift+; 输入冒号，然后按一下 w 和 q，然后按一下回车）保存。\n 注意：不要在文件中输入一个 :wq，是在命令模式输入。\n 保存之后，执行：\npluvet@localos:~ $ source ~/.bashrc 使其生效。\n使 sudo 语句也使用代理\r#\r\r现在 wget 之类的程序已经可以使用代理了。但是 sudo 指令还不能。操作如下：\nsudo 编辑 /etc/sudoers：\npluvet@localos:~ $ sudo vi /etc/sudoers 按 / 打开搜索，输入 env_reset：\n回车定位到其位置，在这行之后新建一行，写入\nDefaults env_keep=\u0026quot;http_proxy https_proxy\u0026quot;\r然后保存：\n若是提示文件 Readonly，可以用 wq! 强制保存。\n接下来，依次执行：\npluvet@localos:~ $ sudo apt update pluvet@localos:~ $ sudo apt install curl pluvet@localos:~ $ curl -l http://www.google.com 如果能看到满屏的 HTML 代码（而不是报错），说明成功了。\n"});index.add({'id':4,'href':'/docs/1.4-%E4%B8%BA-ubuntu-%E5%AE%89%E8%A3%85%E5%A2%9E%E5%BC%BA%E5%8A%9F%E8%83%BD/','title':"1.4 为 Ubuntu 安装增强功能",'section':"Docs",'content':"为 Ubuntu 安装增强功能\r#\r\r准备工作\r#\r\r先登录。\n按下 Ctrl+Alt+T 呼出终端。\n执行如下指令：\n 注意：你需要输入的指令是 $ 后面这部分，也即 sudo apt update，后面的也是一样。前面的 pluvet@localos 表示用户和主机名，在终端上是不能直接编辑的，你的输入光标一开始就会在 $ 后面。打上命令之后，按回车执行命令。按 Ctrl+C 强行中止执行。\n pluvet@localos:~$ sudo apt update 然后执行：\npluvet@localos:~$ sudo apt install virtualbox-guest-utils virtualbox-guest-dkms 等待执行完成。\n 注意：你可能会遇到下载失败（Failed to fetch\u0026hellip;），解决方法见《为 Ubuntu 解除网络封锁》。\n 插入虚拟安装光盘\r#\r\r在菜单点击 设备 / 安装增强功能：\n点击 Run 并输入密码：\n等。\n读上面的字，如果没有出现 Failed，Unable 之类的负面词汇，说明你成功了。\n回车。关机：\n重启后即可生效。\n常用配置\r#\r\r设置分辨率\r#\r\r启用双向剪贴板共享\r#\r\r启用拖放同理。\n"});index.add({'id':5,'href':'/docs/1.5-%E4%B8%BA-ubuntu-%E9%85%8D%E7%BD%AE-ssh-%E8%BF%9E%E6%8E%A5%E5%B9%B6%E5%AF%B9%E6%8E%A5-vscode/','title':"1.5 为 Ubuntu 配置 S S H 连接并对接 v S Code",'section':"Docs",'content':"为 Ubuntu 配置 SSH 连接并对接 VSCode\r#\r\r以下以 母机 代称虚拟机所运行在的实体机。\n生成密钥\r#\r\r在母机 PowerShell 中，执行如下命令，\nPS C:\\Windows\\system32\u0026gt; cd ~/.ssh PS C:\\Users\\i\\.ssh\u0026gt; ls 目录: C:\\Users\\i\\.ssh Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2021-01-06 23:33 142 config -a---- 2021-01-06 23:24 1679 id_rsa -a---- 2021-01-06 23:24 400 id_rsa.pub -a---- 2021-01-06 23:34 176 known_hosts 可以看到存在 id_rsa, id_rsa.pub 文件，说明已经有密钥了。\n 如果执行 ls 命令报错，或者你的用户名含有中文，说明你还没有密钥，建议通过 mkdir c:\\ssh 创建文件夹。然后保存位置写成 c:\\ssh\\id_rsa\n 如果你没有，请如此生成一个：\n执行：\nPS C:\\Users\\i\\.ssh\u0026gt; ssh-keygen -o Enter file in which to save the key (C:\\Users\\i/.ssh/id_rsa): （按一下回车）  注：Enter file in which to save the key (C:\\Users\\i/.ssh/id_rsa): 后面可以手动填写保存位置，回车确认。\n 之后输入密码，可以留空。然后回车。之后执行 ls 指令，可看到生成的文件。\n 这些密钥包括公钥：id_rsa.pub 和私钥 id_rsa 两个文件。\n公钥和私钥用于加密和解密。你可以公开你的公钥，但私钥无论如何都不能公开。\n加密的算法称为 非对称加密。你可以理解为：你把自己的锁头公开，大家都可以用你的锁加密，但是加密之后只有你的私钥能解锁，其他任何能都不能解锁。\n对于我们的 SSH 服务器，你可以理解为：安装了公钥的机器，我们都可以用私钥登录，而没有你的私钥的人不能登录。\n 下面我们查看公钥：\nPS C:\\Users\\i\\.ssh\u0026gt; cat ~\\.ssh\\id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0qD7ZFS1iPXdla1tku2UPZN8XoCCMSt0WCdLzVafb/qZNVJdOM6kSv3zeEDukAvWOcOXA0+J6bkxiV6TJuOcyqq5S5uXZPSC5LpbWyyMINygKE+Cb2WK6dvWzD3INxtV81sBuEhw2xhN7upVYrbAB5x1W3a0Ewu75JY0zExpvmUxd3OHUtlavlr3qBveqZLccYSLcymYYAkla4muvtpdamspkEuQMeHFV+K1/U6Gh/nmQ6tOPeBaCzCsh8SQYknc3+Jdckj3K1stltCGNqwwsf/1AYX4Qg5YJok0bP/qk5aFMdmh2gsxwC6zthyUsI/6+zZn4KXAXeMfSuVU/Ti0B i@DESKTOP-8LN4JKI 将 ssh-rsa ... 复制。后面要用。\n（注：不要复制我的，每个人不一样的哦。当然我不介意你把自己的电脑控制权交给我~）\nVirtual Box 的配置\r#\r\r关机后，打开虚拟机的设置界面：\n找到 网络 / 网卡 2：\n勾选 启用网络连接，连接方式为 仅主机（Host-Only）网络。\n查看虚拟机分配到的 IP 地址\r#\r\r开机，然后打开终端。执行如下命令：\npluvet@localos:~$ ip addr 注意结果中的 inet 后面部分，就是你的虚拟机的 IP 地址：\n我们关注的是 192.168.56.xxx 这个地址，是关联到 VirtualBox 的网卡的。这里是 192.168.56.101。\n在母机中执行以下命令：\nPS C:\\Windows\\system32\u0026gt; ping 192.168.56.101 正在 Ping 192.168.56.101 具有 32 字节的数据: 来自 192.168.56.101 的回复: 字节=32 时间\u0026lt;1ms TTL=64 来自 192.168.56.101 的回复: 字节=32 时间\u0026lt;1ms TTL=64 192.168.56.101 的 Ping 统计信息: 数据包: 已发送 = 2，已接收 = 2，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 0ms，最长 = 0ms，平均 = 0ms Control-C 这表示 Ping 通。\n在 Ubuntu 安装 SSH 服务器\r#\r\r执行如下指令：\npluvet@localos:~$ sudo apt-get install -y openssh-server 如此确认结果：\nluvet@localos:~$ sudo service ssh status ● ssh.service - OpenBSD Secure Shell server Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled) Active: active (running) since Fri 2021-01-22 19:59:18 CST; 47s ago Docs: man:sshd(8) man:sshd_config(5) Main PID: 3276 (sshd) Tasks: 1 (limit: 1104) Memory: 1.4M CGroup: /system.slice/ssh.service └─3276 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups 1月 22 19:59:18 localos systemd[1]: Starting OpenBSD Secure Shell server... 1月 22 19:59:18 localos sshd[3276]: Server listening on 0.0.0.0 port 22. 1月 22 19:59:18 localos sshd[3276]: Server listening on :: port 22. 1月 22 19:59:18 localos systemd[1]: Started OpenBSD Secure Shell server. 看到 active (running)，说明成功。\n通过 SSH 连接到虚拟机\r#\r\r在母机中执行：\nPS C:\\Users\\i\\.ssh\u0026gt; ssh pluvet@192.168.56.101 The authenticity of host \u0026#39;192.168.56.101 (192.168.56.101)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:RtmUrCnlAAl+sJriAY095r1qROL5ePob8I7BSY99K4o. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added \u0026#39;192.168.56.101\u0026#39; (ECDSA) to the list of known hosts. pluvet@192.168.56.101\u0026#39;s password: Welcome to Ubuntu 20.10 (GNU/Linux 5.8.0-25-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage 205 updates can be installed immediately. 83 of these updates are security updates. To see these additional updates run: apt list --upgradable The programs included with the Ubuntu system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. pluvet@localos:~$ 其中 pluvet 是你设置的用户名。\n192.168.56.101 是 Ubuntu 的 IP 地址。\n安装密钥\r#\r\r在刚才连入的 Ubuntu 终端执行如下指令：\npluvet@localos:~$ mkdir ~/.ssh pluvet@localos:~$ vi ~/.ssh/authorized_keys 将公钥添加到文件中，保存：\n重启 SSH 服务：\npluvet@localos:~$ sudo service ssh restart 现在，应该可以免密码登录了。\n检验密钥登录\r#\r\r退出终端：\npluvet@localos:~$ exit logout Connection to 192.168.56.101 closed. PS C:\\Users\\i\\.ssh\u0026gt; 再次执行：\nPS C:\\Users\\i\\.ssh\u0026gt; ssh pluvet@192.168.56.101 Welcome to Ubuntu 20.10 (GNU/Linux 5.8.0-25-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage 205 updates can be installed immediately. 83 of these updates are security updates. To see these additional updates run: apt list --upgradable Last login: Fri Jan 22 20:02:51 2021 from 192.168.56.1 pluvet@localos:~$ 可以看到，直接登录成功。这是因为默认使用了 ~/.ssh/id_rsa 私钥进行登录。\n配置 VSCode 远程开发\r#\r\r首先我们安装几个常用软件：\npluvet@localos:~$ sudo apt install -y wget git curl vim 然后，在 Windows 上安装 VSCode，并安装 Remote - SSH 扩展：\n点击左下角按钮：\n打开配置文件：\n编辑第一个：\n在打开的文件中追加如下内容：\nHost local_os\rHostName 192.168.56.101\rUser pluvet\rIdentityFile C:/ssh/id_rsa # 这里根据你的情况填写私钥位置，如果是默认位置，就直接删掉这行。\r保存。然后点击左下角按钮：\n选择第一项或第二项：\n点击你要连接的服务器：\n类型选择 Linux：\n连接成功后，可如此操作进入终端：\n新建个文件夹：\n执行 code 文件夹/文件 即可编辑文件夹 / 文件：\n"});index.add({'id':6,'href':'/docs/1.6-%E5%9C%A8-ubuntu-%E4%B8%AD%E5%AE%89%E8%A3%85-bochs-%E8%99%9A%E6%8B%9F%E6%9C%BA/','title':"1.6 在 Ubuntu 中安装 Bochs 虚拟机",'section':"Docs",'content':"下载 Bochs\r#\r\r访问 Bochs x86 PC emulator - Browse /bochs at SourceForge.net。\n找到最新版：\n我们要编译安装，所以下载 bochs-2.6.11.tar.gz\n下载之后是存放在 Windows 上的（当然，你也可以直接在 Ubuntu 中打开 Firefox 浏览器下载），我们直接用 VSCode 传输到 Ubuntu 中。\n传输源代码到 Linux 中\r#\r\r在 VSCode 打开终端（Ctrl+Shift+~），在 ~ 下创建 dev 目录：\n打开这个目录：\n然后将文件从 Windows 资源管理器直接拖进来就行：\n执行：\npluvet@localos:~/dev$ tar -zvxf bochs-2.6.11.tar.gz 进行解压。\n进入解压到的目录\npluvet@localos:~/dev$ cd bochs-2.6.11/ 编译安装\r#\r\r以防万一，请先执行：\nsudo apt install libx11-dev\rsudo apt install xorg-dev\r编辑 bx_debug/dbg_main.cpp，变更如下：\nDescription: Fix the build with SMP enabled Origin: https://sourceforge.net/p/bochs/code/13778/ Index: bochs/bx_debug/dbg_main.cc =================================================================== --- bochs/bx_debug/dbg_main.cc\t(revision 13777) +++ bochs/bx_debug/dbg_main.cc\t(working copy) @@ -1494,11 +1494,11 @@  { char cpu_param_name[16]; - Bit32u index = BX_ITLB_INDEX_OF(laddr);\t//这一行改成下面一行 + Bit32u index = BX_CPU(dbg_cpu)-\u0026gt;ITLB.get_index_of(laddr);  sprintf(cpu_param_name, \u0026#34;ITLB.entry%d\u0026#34;, index); bx_dbg_show_param_command(cpu_param_name, 0); - index = BX_DTLB_INDEX_OF(laddr, 0);\t//同理 + index = BX_CPU(dbg_cpu)-\u0026gt;DTLB.get_index_of(laddr);  sprintf(cpu_param_name, \u0026#34;DTLB.entry%d\u0026#34;, index); bx_dbg_show_param_command(cpu_param_name, 0); } 再执行：\ncp misc/bximage.cpp misc/bximage.cc cp iodev/hdimage/hdimage.cpp iodev/hdimage/hdimage.cc cp iodev/hdimage/vmware3.cpp iodev/hdimage/vmware3.cc cp iodev/hdimage/vmware4.cpp iodev/hdimage/vmware4.cc cp iodev/hdimage/vpc-img.cpp iodev/hdimage/vpc-img.cc cp iodev/hdimage/vbox.cpp iodev/hdimage/vbox.cc 以上是为了避免你之后遇到各种 bug。\n为了知道如何安装，我们看一下 bochs: The Open Source IA-32 Emulation Project (New Bochs Documentation) (sourceforge.net) 这里的文档。\n我使用的 configure 指令如下：\npluvet@localos:~/dev/bochs-2.6.11$ ./configure --with-x11 --with-wx --enable-debugger --enable-disasm --enable-all-optimizations --enable-readline --enable-long-phy-address --enable-ltdl-install --enable-idle-hack --enable-plugins --enable-a20-pin --enable-x86-64 --enable-smp --enable-cpu-level=6 --enable-large-ramfile --enable-repeat-speedups --enable-fast-function-calls --enable-handlers-chaining --enable-trace-linking --enable-configurable-msrs --enable-show-ips --enable-cpp --enable-debugger-gui --enable-iodebug --enable-logging --enable-assert-checks --enable-fpu --enable-vmx=2 --enable-svm --enable-3dnow --enable-alignment-check --enable-monitor-mwait --enable-avx --enable-evex --enable-x86-debugger --enable-pci --enable-usb 执行后会看到一系列的 checking 操作。\n正常情况结尾应该是类似这样：\n接下来执行 make 编译：\npluvet@localos:~/dev/bochs-2.6.11$ make 看到很多这样的 warning 不用理会：\n 如果是 error 就得找找原因了。\n 我这里遇到了如下报错：\nx.cc:37:10: fatal error: X11/Xlib.h: No such file or directory\r37 | #include \u0026lt;X11/Xlib.h\u0026gt;\r| ^~~~~~~~~~~~\rcompilation terminated.\rmake[1]: *** [Makefile:114: x.o] Error 1\rmake[1]: Leaving directory '/home/pluvet/dev/bochs-2.6.11/gui'\rmake: *** [Makefile:360: gui/libgui.a] Error 2\r谷歌搜索之后，在 SOF 上看到如下解决方案\nsudo apt install libx11-dev sudo apt install xorg-dev 根据指示，安装 libx11-dev 包，然后重新 make 。\n此外还遇到如下报错：\n/home/pluvet/dev/bochs-2.6.11/gui/x.cc:1535: undefined reference to `XCreateBitmapFromData'\r/usr/bin/ld: gui/libgui.a(x.o): in function `bx_x_gui_c::palette_change(unsigned char, unsigned char, unsigned char, unsigned char)':\r/home/pluvet/dev/bochs-2.6.11/gui/x.cc:1478: undefined reference to `XStoreColor'\r/usr/bin/ld: /home/pluvet/dev/bochs-2.6.11/gui/x.cc:1482: undefined reference to `XAllocColor'\r编译的过程会比较缓慢。成功之后看到的类似这样：\n正式安装，执行：\npluvet@localos:~/dev/bochs-2.6.11$ sudo su root@localos:/home/pluvet/dev/bochs-2.6.11# make install 成功之后看到的类似这样：\n执行\nroot@localos:/home/pluvet/dev/bochs-2.6.11# exit 退出 root 用户。\n创建 Bochs 虚拟机配置文件\r#\r\r在 bochs-xxx 文件夹中，有一个示例配置文件 .bochsrc，我们将其复制到 ~/dev/vm 目录：‘\npluvet@localos:~/dev$ mkdir vm pluvet@localos:~/dev$ mv bochs-2.6.11/.bochsrc vm 编辑这个配置文件，内容如下：\n# configuration file generated by Bochs\rplugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1\rconfig_interface: textconfig\rdisplay_library: x\r#memory: host=2048, guest=2048\rromimage: file=\u0026quot;/usr/local/share/bochs/BIOS-bochs-latest\u0026quot;\rvgaromimage: file=\u0026quot;/usr/local/share/bochs/VGABIOS-lgpl-latest\u0026quot;\rboot: floppy\rfloppy_bootsig_check: disabled=0\rfloppya: type=1_44, 1_44=\u0026quot;boot.img\u0026quot;, status=inserted, write_protected=0\r# no floppyb\rata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14\rata0-master: type=none\rata0-slave: type=none\rata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15\rata1-master: type=none\rata1-slave: type=none\rata2: enabled=0\rata3: enabled=0\rpci: enabled=1, chipset=i440fx\rvga: extension=vbe, update_freq=5\rcpu: count=1:1:1, ips=4000000, quantum=16, model=corei7_haswell_4770, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0, msrs=\u0026quot;msrs.def\u0026quot;\rcpuid: x86_64=1,level=6, mmx=1, sep=1, simd=avx512, aes=1, movbe=1, xsave=1,apic=x2apic,sha=1,movbe=1,adx=1,xsaveopt=1,avx_f16c=1,avx_fma=1,bmi=bmi2,1g_pages=1,pcid=1,fsgsbase=1,smep=1,smap=1,mwait=1,vmx=1\rcpuid: family=6, model=0x1a, stepping=5, vendor_string=\u0026quot;GenuineIntel\u0026quot;, brand_string=\u0026quot;Intel(R) Core(TM) i7-4770 CPU (Haswell)\u0026quot;\rprint_timestamps: enabled=0\rdebugger_log: -\rmagic_break: enabled=0\rport_e9_hack: enabled=0\rprivate_colormap: enabled=0\rclock: sync=none, time0=local, rtc_sync=0\r# no cmosimage\r# no loader\rlog: -\rlogprefix: %t%e%d\rdebug: action=ignore\rinfo: action=report\rerror: action=report\rpanic: action=ask\rkeyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=none\rmouse: type=ps2, enabled=0, toggle=ctrl+mbutton\rspeaker: enabled=1, mode=system\rparport1: enabled=1, file=none\rparport2: enabled=0\rcom1: enabled=1, mode=null\rcom2: enabled=0\rcom3: enabled=0\rcom4: enabled=0\rmegs: 2048\r执行\npluvet@localos:~/dev/vm$ bochs -help cpu 可以查看支持模拟的 CPU。\n"});index.add({'id':7,'href':'/docs/2.1-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F/','title':"2.1 第一个引导程序",'section':"Docs",'content':"什么是 BIOS\r#\r\rBIOS 就是内置在主板上的一个程序，当系统启动时，会执行 BIOS 中的代码，进行设备检查（称为自检）等等。当检查通过之后，会读取 启动设备 中的引导程序，从而将操作系统加载到内存运行。\n什么是引导程序\r#\r\r引导程序就是讲操作系统加载到内存，运行整个操作系统的程序。\nBIOS 如何执行引导程序\r#\r\rBIOS 会读取启动设备的前 512B（B 是字节单位，Byte），这些字节是设备的第一个扇区，如果这个扇区的结束字节是 0x55, 0xaa 则表示这个扇区是可引导扇区，这些字节称为（即主引导记录（master boot record，MBR）），将这一块加载到物理内存（具体位置是 0x7c00）中，然后执行其中的二进制代码（这些代码就是引导程序）。\n安装 NASM\r#\r\rNASM 是将汇编代码编译为二进制的工具。安装方式：\nsudo apt install nasm 安装 HexEdit\r#\r\rHexedit 是一个十六进制编译器。安装：\nsudo apt install hexedit 第一个引导程序\r#\r\r下面，我们用 Intel 汇编，编写一个最简单的引导程序：\n; 告知编译器程序的起始位置\rorg 0x7c00\rBaseOfStack equ 0x7c00\rLabel_Start:\rmov ax, cs\rmov ds, ax\rmov es, ax\rmov ss, ax\rmov sp, BaseOfStack\r; ======== 清屏\rmov ax, 0600h\rmov bx, 0700h\rmov cx, 0\rmov dx, 0184fh\rint 10h\r; ======== 设置焦点\rmov ax, 0200h\rmov bx, 0000h\rmov dx, 0000h\rint 10h\r; ======== 在屏幕上显示 Start Booting...\rmov ax, 1301h\rmov bx, 000fh\rmov dx, 0000h\rmov cx, 10\rpush ax\rmov ax, ds\rmov es, ax\rpop ax\rmov bp, StartBootMessage\rint 10h\r; ======== reset floppy\rxor ah, ah\rxor dl, dl\rint 13h\rjmp $\rStartBootMessage: db \u0026quot;Start Booting...\u0026quot;\r; ======== 填充 0\rtimes 510 - ($ - $$) db 0\rdw 0xaa55\r执行下列命令编译：\npluvet@localos:~/dev/vm$ nasm boot.asm -o boot.bin 用 HexEdit 查看编译出来的二进制文件：\npluvet@localos:~/dev/vm$ hexedit boot.bin 00000000 8C C8 8E D8 8E C0 8E D0 BC 00 7C B8 00 06 BB 00 ..........|.....\r00000010 07 B9 00 00 BA 4F 18 CD 10 B8 00 02 BB 00 00 BA .....O..........\r00000020 00 00 CD 10 B8 01 13 BB 0F 00 BA 00 00 B9 0A 00 ................\r00000030 50 8C D8 8E C0 58 BD 43 7C CD 10 30 E4 30 D2 CD P....X.C|..0.0..\r00000040 13 EB FE 53 74 61 72 74 20 42 6F 6F 74 69 6E 67 ...Start Booting\r00000050 2E 2E 2E 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000060 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000070 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000080 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000090 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000000A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000000B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000000C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000000D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000000E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000000F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000100 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000110 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000120 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000130 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000150 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000160 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000170 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000180 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r00000190 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000001A0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000001B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000001C0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000001D0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000001E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\r000001F0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 AA ..............U.\r可以发现前面是我们的代码，中间 0 填充，最后是扇区标志 55AA 按 Ctrl+X 退出。\n 为什么汇编代码中是 0xaa55，而这里是 55AA 呢？请阅读 CSAPP 大端序、小端序的相关章节。\n 执行如下指令将 boot.bin 写入镜像文件的前 512 字节：\npluvet@localos:~/dev/vm$ dd if=boot.bin of=./boot.img bs=512 count=1 conv=notrunc 1+0 records in 1+0 records out 512 bytes copied, 0.000660162 s, 776 kB/s 执行下列指令运行虚拟机：\npluvet@localos:~/dev/vm$ bochs -f ./.bochsrc 下列界面回车：\n![image-20210206153513311](A:\\Project\\osdev\\blog\\os-dev\\web\\content\\docs\\2.1 引导原理与引导程序.assets\\image-20210206153513311.png)\n之后会黑屏：\n![image-20210206153532680](A:\\Project\\osdev\\blog\\os-dev\\web\\content\\docs\\2.1 引导原理与引导程序.assets\\image-20210206153532680.png)\n切换到 bochs 控制台窗口，执行 c （表示 Continue）：\n\u0026lt;bochs:1\u0026gt; c 成功结果如下：\n![image-20210206153648371](A:\\Project\\osdev\\blog\\os-dev\\web\\content\\docs\\2.1 引导原理与引导程序.assets\\image-20210206153648371.png)\n在bochs 控制台窗口，按下 Ctrl+C 可以中止虚拟机的运行。然后执行 exit 退出：\n\u0026lt;bochs:1\u0026gt; exit "});index.add({'id':8,'href':'/posts/bochs-%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/','title':"Bochs 调试常用命令",'section':"Posts",'content':"转载自：Bochs调试常用命令 | Ney的技术博客 (petpwiuta.github.io)\n1 简介\r#\r\rBochs是做系统开发常用的虚拟机，调试系统内核很方便。\n安装Bochs一般是从源码编译再安装，而调试器属于可选功能，所以在编译Bochs时需要使用--enable-debugger和--enable-disasm标志开启调试模块。例如：\n./configure --enable-debugger --enable-disasm #后面还有其他选项，此处省略\r需要注意调试功能在 2.5.4 版本以上才有，确保下载的代码是高于这个版本的。\n2 常见的几个使用场景\r#\r\r2.1 查看寄存器\r#\r\r汇编代码中，调试最常用的功能就是查看寄存器的内容。\n r 查看通用寄存器 sreg 查看段寄存器 creg 查看控制寄存器 dreg 查看调试寄存器 info cpu 查看所有寄存器  2.2 查找和定位代码\r#\r\r次常用的肯定是控制代码执行流程，代码执行到想要仔细跟踪的那个部分。\n  b 内存地址 设置断点\n如b 0x7c00，在线性地址0x7c00处设置断点。\n  info break 查看设置过的断点\n  c 继续执行代码\n一般设置断点后，想让代码恢复执行，就使用这个命令。\n  s 单步执行\n单步执行一行代码，和高级语言调试器的step into按钮类似，遇到函数调用会跳转到函数内部执行。单步执行命令也可以带参数，指定执行的次数，如 s 100 就是单步执行100次。\n  n 执行下一行\n它和单步执行类似，单步执行遇到循环和函数时会跳转到内部，而n命令会执行完循环和函数，类似于step over，这样在遇到大量的循环或者较长的函数时，可以用n命令来执行到下一行。\nn命令能跳转到下一行是因为loop或者call执行有明显的结束标记（前者通过cx寄存器，后者通ret指令），如果遇到用jmp语句写的循环这种情况，没有明显结束标记的，可以用下面的u命令反汇编代码的地址，找到循环的下一行指令的地址，然后给该地址加一个断点就能达到同样的效果。\n  u 反汇编代码\n直接使用u命令会反汇编当前执行的指令，它可以加参数， u /反汇编数量 起始地址 ，如 u /20 0x7c00 就是从0x7c00处开始，反汇编20条指令，如果没有起始地址就是从当前地址开始。\n它还可以反汇编一个范围的代码，u 起始地址 结束地址 ，如u 0x7c00 0x7cff 就是反汇编0x7c00到0x7cff的代码。\n  2.3 查看内存\r#\r\r x /nuf 地址 查看线性地址处的内存内容。 xp /nuf 地址 查看物理地址处的内存内容。  n 指定要显示的内存单元的数量\ru 显示的内存单元的大小，如下参数之一\rb 单个字节\rh 半个字(2 字节)\rw 一个字(4 字节)\rf 打印的格式。如下类型之一：\rx 按照十六进制形式打印\rd 按照十进制形式打印\ru 以无符号的10进制打印\ro 按照八进制形式打印\rt 按照二进制行是打印\r2.4 Tips\r#\r\rBochs还有一个比较有用的设计就是，当你输入指令后，直接按回车键（Enter Key）会重复上一次的命令。比如上一个命令是单步执行s，此时直接按回车键就相当于s的功能。\n3 调试指令手册\r#\r\r3.1 执行控制\r#\r\r   命令 解释     c / cont / continue 继续执行   s / step [count] 执行count条指令，如果不指定参数，默认值为1   s / step [cpu] [count] 对于对称多处理器结构模拟，在cpu上执行count条指令，count的默认值为1   s / step all [count] 对于对称多处理器结构模拟，所有cpu上都执行count条指令，count的默认值为1   Ctrl-C 停止执行，返回到命令行提示符   Ctrl-D 如果在空行上执行，则退出调试器   q / quit / exit 退出调试器，继续执行    3.2 断点操作\r#\r\r   命令 解释     ① vbreak / vb segment:offset 设置虚拟地址指令断点，segment和offset指段地址和段内偏移量   ② lbreak / lb addr 在线性地址指令上设置断点   ③ pbreak / bp [*] addr 在物理地址上设置断点   ④ break / b [*] addr 同上。 * 符号是兼容GDB命令，为可选参数   info break 显示当前所有断点状态   bpe n 开启断点   bpd n 关闭断点   delete / del / d n 删除断点    注意：① ② ③ ④ 的命令都可以设置条件，即都可以变成条件断点。具体做法是在命令之后添加if condition ，如vbreak 0x008:0x001 if \u0026quot;条件表达式\u0026quot;\n3.3 内存观察点\r#\r\r内存观察点类似于内存的监听器，当指定地址的内存产生读取或者写入事件时，会产生中断。\n   命令 解释     watch read/r addr 在物理地址addr上插入读观察点   watch write/w addr 在物理地址addr上插入一个写观察点   watch 显示当前内存观察点的状态   watch stop 当遇到观察点时，停止模拟执行（默认）   watch continue 在遇到观察点时，不要停止模拟执行   unwatch addr 移除指定物理地址上的观察点   unwatch 移除所有的观察点   trace-mem on/off 开启/关闭 内存访问追踪    3.4 内存操作\r#\r\r   命令 解释     x /nuf addr 在线性地址addr处检查内存内容，nuf的解释在前面列出   xp /nuf addr 在物理地址 addr处查看内存内容，nuf的解释在前面列出   setpmem addr datasize value 在内存位置addr处设置datasize大小内存，值为 value   writemem filepath addr datasize 从线性地addr处dump出datasize个字节到文件filepath中   crc addr1 addr2 显示物理地址范围 addr1到addr2之间内容的 CRC值    3.5 查看信息\r#\r\r   命令 解释     r / reg / regs / registers 查看通用寄存器内容   fp / fpu 查看FPU寄存器内容   mmx 查看MMX寄存器内容   sse / xmm 查看SSE寄存器内容   ymm 查看AVX寄存器内容   sreg / dreg / creg 查看 段 / 调试 / 控制 寄存器内容   info cpu 查看所有寄存器内容   info eflags 查看标志寄存器内容   info break 显示当前所有断点状态   info tab 显示分页地址转换   info device 显示指定设备的状态    3.6 寄存器操作\r#\r\r   命令 解释     set reg = expr 修改reg寄存器值为expr    注意：只能修改通用寄存器和指令寄存器。不能够修改标志寄存器，段寄存器，浮点寄存器和SIMD寄存器。\n3.7 反汇编\r#\r\r   命令 解释     u addr1 addr2 在给定的线性地址范围内反汇编指令，包含start处指令，不包含end处指令   u switch-mode 在Intel和 AT\u0026amp;T两种汇编风格之间切换   u size = n 设定反汇编命令的位数，使用0，16，32。值0意思是使用当前的CS段寄存器，默认值是0   set u on 每次停止执行时就自动反汇编当前的指令   set u off 和上一条相反，不自动反汇编    3.8 指令跟踪\r#\r\r   命令 解释     trace on 反汇编每一条执行的指令。引起异常的指令都没有真正执行，因此也不会被跟踪   trace off 关闭指令跟踪功能    3.9 指令编程环境\r#\r\rBochs的instrument功能，提供了运行时的各种钩子函数。它也是可选功能，在编译安装时需要开启--enable-instrumentation选项指定。\n./configure [...] --enable-instrumentation\r./configure [...] --enable-instrumentation=\u0026quot;instrument/stubs\u0026quot;\r自定义的代码要创建一个独立的目录，例如”instrument/myinstrument”，将”instrument/stubs”目录拷贝进去，然后使用如下的指令设定：\n./configure [...] --enable-instrumentation=\u0026quot;instrument/myinstrument\u0026quot;\r指令命令：\ninstrument [command] 用[command]调用BX_INSTR_DEBUG_CMD指令回调\r3.10 show指令\r#\r\r   命令 解释     show 打印当前的符号信息显示模式   show mode 当处理器切换模式时打印   show int 当产生中断时打印   show call 当产生调用时打印   show ret 当函数返回时打印   show off 关闭打印   show dbg-all 开启所有显示标志   show dbg-none 关闭所有显示标志    3.11 其他命令\r#\r\r   命令 解释     ptime 打印当前的时间（从开始模拟到现在的ticks）   sb delta 在未来执行中插入一个时间断点delta。delta是一个64位的整数，跟着字母”L”，例如1000L   sba time 在时间time处插入一个时间断点 。time 同上面的delta   print-stack [num] 打印栈顶端的num个字   modebp 触发CPU模式转换断点   ldsym [global] filename [offset] 从文件filename加载符号。    4 参考\r#\r\r 8.14. Using Bochs internal debugger bochs/instrument  "});index.add({'id':9,'href':'/posts/git-%E9%80%9F%E6%88%90%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/','title':"Git 速成入门指南",'section':"Posts",'content':"由于网上的教程要么啰嗦，要么太过随意、太旧，所以写了这篇指南，尽可能取得实战能力、原理理解、学习效率的平衡。\n什么是 Git？\r#\r\rGit 是一个文件管理工具，用于需要处理文件合并、更新等操作和这些操作的追踪。想象你在写一个程序，这个程序涉及到 A, B, C\u0026hellip; 各个源代码文件，有一天，你修改了文件 C，然后重新发布了程序，突然你发现这个修改会导致严重的 BUG，你必须恢复到原来的文件，于是每次修改你都要把当时的源代码保存一遍，非常麻烦。或者假设有很多人帮助你开发这个程序，你就要手动合并他们提交的代码。有了 Git 之后，我们可以方便地管理代码的各个版本、管理其他人的合并等等。\n前置知识\r#\r\r学习之前，你需要知道：\n 常用的 Linux 命令 Vim 编辑器基本操作  注册一个 Github 账号\r#\r\rGithub 是一个在线的代码托管平台，使用 Github 你可以将自己的代码推送到服务器，或者从服务器下载代码。类似的平台还有 Gitee、GitBucket、Bitbucket 等，他们都支持 Git。此外你也可以自己搭建一个代码托管服务器。\n为了我们后面学习过程中方便演练各种操作，需要你注册一个 Github 账号，或者使用你有的账号。\n访问 GitHub: Where the world builds software · GitHub，点击 Sign up 按钮进入注册页面，填写必要的信息进行注册。\n安装 Git\r#\r\r我们以 Linux（Ubuntu）系统为例。执行：\n$ sudo apt-get install git -y 进行安装。\n配置用户信息\r#\r\r之后你需要配置用户信息。执行：\n$ git config --global user.name \u0026quot;pluvet\u0026quot;\r$ git config --global user.email pluvet@foxmail.com\r填写你自己的用户名和邮箱。这里的信息建议和你的 Github 账号一致。\n配置代理\r#\r\r$ git config --global https.proxy http://192.168.56.1:10809 $ git config --global https.proxy http://192.168.56.1:10809 创建仓库\r#\r\r仓库（Repository）是被 Git 管理的一个目录。当一个目录变成仓库之后，我们可以在里面使用 Git 的命令跟踪文件的增减和变更。\n我们创建一个文件夹，并进入它：\npluvet@localos:~$ mkdir learn-git pluvet@localos:~$ cd learn-git/ 然后我们在里面创建一个文件夹（作为仓库），并进入它：\npluvet@localos:~/learn-git$ mkdir my-repo pluvet@localos:~/learn-git$ cd my-repo/ 这个时候，它还只是一个普通文件夹。要变成 Git 可管理的仓库，执行：\npluvet@localos:~/learn-git/my-repo$ git init Initialized empty Git repository in /home/pluvet/learn-git/my-repo/.git/ 现在，仓库就初始化完毕了。\n添加文件\r#\r\r从工作目录到暂存区\r#\r\r创建一个文本文件：\npluvet@localos:~/learn-git/my-repo$ vi hello.txt 写入内容：\nThis is a sample file.\r保存。现在 hello.txt 已经位于 工作目录（Working Directory） 了。\n现在，要让 Git 仓库托管这个文件，需要使用 add 命令将其添加到暂存区（Stage，也叫索引）：\npluvet@localos:~/learn-git/my-repo$ git add hello.txt  添加命令：添加一个或者多个文件到索引（暂存区）。\ngit add \u0026lt;filename\u0026gt;\ngit add *\n 从暂存区到本地仓库\r#\r\r下面将代码从暂存区提交到本地仓库：\npluvet@localos:~/learn-git/my-repo$ git commit -m \u0026#34;add: hello.txt\u0026#34; [master (root-commit) 9ec197f] add: hello.txt 1 file changed, 1 insertion(+) create mode 100644 hello.txt  提交命令：将变更提交到本地仓库。\ngit commit -m \u0026quot;提交说明\u0026quot;\n 从本地仓库到远程仓库\r#\r\r下面还可以继续提交到远程仓库。不过，我们还没有一个远程仓库。现在我们创建一个。\n访问 Create a New Repository (github.com)，如下图填写仓库名称，点击 Create repository：\n片刻之后可以看到创建好的仓库。我们复制仓库的地址：\n执行：\npluvet@localos:~/learn-git/my-repo$ git remote add origin https://github.com/pluveto/my-repo-1.git 即可添加远程仓库，为这个远程仓库 https://github.com/pluveto/my-repo-1.git 取别名为 origin。\n执行：\ngit push --set-upstream origin master\r即可推送到远程仓库。其中 --set-upstream origin master 表示设定 origin 为上游仓库（注意：origin表示的是远程仓库，是我们上一步自己取的名字），而后面的 master 是 git push 的参数。之所以要设置 上游仓库 是为了保证 Git 知道要推送到哪里。因为 一个代码库可以推送到多个上游，比如你可以推送到 Gitee 和 Github。当设置了一次上游仓库，以后再执行推送，就不用指名了，就默认用第一次设置的了。也就是以后推送就可以执行：\ngit push --set-upstream origin master\r 有的说法是上游分支，但是这个说法不准确，因为后面的一个仓库里面也有不同的分支（branch），所以还是叫上游仓库不会误导读者。\n  推送命令：将本地仓库推送到远程仓库。\ngit push origin master\norigin 是上游仓库名，master 是推送的分支名。这条命令可以省略为：git push\n 向上推送小结\r#\r\r现在我们总结一下：\n 创建文件后，文件保存在 工作目录。 通过 add 命令，添加文件到 暂存区。 通过 commit 命令，提交文件到 本地仓库。 通过 push 命令，推送文件到 远程仓库。  请记住三个区、远程仓库的关系：工作目录→暂存区→本地仓库→远程仓库\n在浏览器访问你的仓库链接，可以看到：\n点进 hello.txt 可以看到里面的内容：\n修改文件并更新推送\r#\r\r创建文件 empty.c，写入：\nint main() { return 0; } 创建文件 empty.html，写入：\n\u0026lt;html\u0026gt; \u0026lt;/html\u0026gt; 现在我们的工作目录有这些文件：\npluvet@localos:~/learn-git/my-repo$ ls -a . .. empty.c empty.html .git hello.txt 批量添加索引\r#\r\r因为我们新增了两个文件，所以把它们添加到索引：\npluvet@localos:~/learn-git/my-repo$ git add .  git add . 表示将当前目录的所有文件都添加到暂存区（除了 .gitignore 中排除的文件，关于 .gitignore 的用法，将会在后续讲到）\n 现在，执行 git status，可以看到：\npluvet@localos:~/learn-git/my-repo$ git status On branch master Your branch is up to date with \u0026#39;origin/master\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: empty.c new file: empty.html 需要提醒的是，git add . 只作用于当前已有的文件。如果我们新建一个空文件，名为 undo：\npluvet@localos:~/learn-git/my-repo$ touch undo pluvet@localos:~/learn-git/my-repo$ git status On branch master Your branch is up to date with \u0026#39;origin/master\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: empty.c new file: empty.html Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) undo 你会看到，undo 位列 Untracked files 名单之中，也就是没有被索引。所以我们要添加到索引：\npluvet@localos:~/learn-git/my-repo$ git add undo pluvet@localos:~/learn-git/my-repo$ git status On branch master Your branch is up to date with \u0026#39;origin/master\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: empty.c new file: empty.html new file: undo 撤销索引\r#\r\r现在我们反悔了，不想索引 undo 文件了，怎么办？执行：\npluvet@localos:~/learn-git/my-repo$ git reset undo pluvet@localos:~/learn-git/my-repo$ git status On branch master Your branch is up to date with \u0026#39;origin/master\u0026#39;. Changes to be committed: (use \u0026#34;git restore --staged \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: empty.c new file: empty.html Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) undo  重置命令：回退命令。\ngit reset \u0026lt;filename\u0026gt;\n 提交到本地仓库\r#\r\rpluvet@localos:~/learn-git/my-repo$ git commit -m \u0026#34;add: two empty source files\u0026#34; 撤销提交\r#\r\r这个时候我们发现代码需要修改，想撤销提交，怎么办？执行：\npluvet@localos:~/learn-git/my-repo$ git reset --soft HEAD^ 回档操作总结\r#\r\r你可能会疑问：前面撤销 add 操作，和这里撤销 commit，用的都是 reset ，区别何在？\n我们先解释一下命令参数的含义。\n$ git reset 某个版本 某个文件 表示重置到”某个版本“。当”某个版本“不填写的时候，就默认是 HEAD. 某个文件就默认是 .，即当前目录所有文件。\nHEAD 表示当前版本。\n HEAD 说明：\n  HEAD 表示当前版本\n  HEAD^ 上一个版本\n  HEAD^^ 上上一个版本\n  HEAD^^^ 上上上一个版本\n  以此类推\u0026hellip;\n  可以使用 ～数字表示\n HEAD~0 表示当前版本 HEAD~1 上一个版本 HEAD^2 上上一个版本 HEAD^3 上上上一个版本 以此类推\u0026hellip;  其实 HEAD 就是链表的头指针，指向当前的 commit。\n 当我们撤销 add 的时候\r#\r\rgit reset：相当于 git reset HEAD .，即：回退所有文件到当前版本，清空暂存区。\n工作目录→暂存区→本地仓库→远程仓库\r↑\r作用最深位置\r当我们撤销 commit 的时候\r#\r\rgit reset --soft HEAD~1：相当于 git reset --soft HEAD~1 .，即回退所有文件到当前版本，但是不清空暂存区。也就是暂存区 add 的文件都还在。\n工作目录→暂存区→本地仓库→远程仓库\r↑\r作用最深位置\r当我们使用 \u0026ndash;hard 参数的时候\r#\r\rgit reset --hard HEAD~1：相当于 git reset --hard HEAD~1 .，即回退所有文件到当前版本，并且连暂存区、工作目录的文件也一并回档。\n工作目录→暂存区→本地仓库→远程仓库\r↑\r作用最深位置\r这种操作在以后撤回 merge 的时候也会用到。\n查看提交历史\r#\r\r现在，重新添加上两个文件，并提交。然后执行：\npluvet@localos:~/learn-git/my-repo$ git log commit 3e19b2abb94d4c579023acccb300b53b186fcdde (HEAD -\u0026gt; master) Author: Pluveto \u0026lt;receding@protonmail.ccom\u0026gt; Date: Sun Jan 24 12:12:07 2021 +0800 add: two empty source files commit 9ec197f9b29bc6b5f432e4f90bd389372a73747d (origin/master) Author: Pluveto \u0026lt;receding@protonmail.ccom\u0026gt; Date: Sat Jan 23 20:20:56 2021 +0800 add: hello.txt 可以看到提交的历史。git log 的详细用法，见：Git - 查看提交历史 (git-scm.com)。\n之后，我们推送到服务器：\npluvet@localos:~/learn-git/my-repo$ git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Compressing objects: 100% (2/2), done. Writing objects: 100% (4/4), 368 bytes | 368.00 KiB/s, done. Total 4 (delta 0), reused 0 (delta 0), pack-reused 0 To https://github.com/pluveto/my-repo-1.git 9ec197f..3e19b2a master -\u0026gt; master  这里，git push 是 git push origin master 的缩写。origin 是我们给远程仓库取的名。master 是我们推送分支的名。\n 拉取文件\r#\r\r在 Github 上添加文件\r#\r\r在 Github 上访问我们的仓库：\n点击上面的 Add file 按钮，新增一个文件，名为 README.md。内容自己写~\n然后在下方提交：\n你可以发现，实际上 github 帮助你创建了文件，然后帮你 add 和 commit 你编辑好的文件。和我们用命令操作是一样的。\n在 Github 上修改文件\r#\r\r点击 hello,txt：\n点击编辑按钮：\n往里面写一句话，然后提交：\n处理版本冲突\r#\r\r现在，把 undo 文件也添加进来：\npluvet@localos:~/learn-git/my-repo$ git add undo 并提交到本地仓库：\npluvet@localos:~/learn-git/my-repo$ git commit -m \u0026#34;add: undo\u0026#34; [master 2d3b5d3] add: undo 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 undo 然后推送到远程仓库：\npluvet@localos:~/learn-git/my-repo$ git push To https://github.com/pluveto/my-repo-1.git ! [rejected] master -\u0026gt; master (fetch first) error: failed to push some refs to \u0026#39;https://github.com/pluveto/my-repo-1.git\u0026#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., \u0026#39;git pull ...\u0026#39;) before pushing again. hint: See the \u0026#39;Note about fast-forwards\u0026#39; in \u0026#39;git push --help\u0026#39; for details. 看，报错了。这是因为产生了冲突。我们分析一下冲突如何产生的：\n 假设本来的版本是 A 你在 Github 网站上进行了两次提交，版本变成了 B，然后变成了 C。 你在本地仓库上进行了一次提交，版本从 A 变成了 D 而你想把 D 推送到远程仓库，远程仓库的上一版本已经不是 A 了，冲突。  AABBCCDDViewer does not support full SVG 1.1我们执行：\npluvet@localos:~/learn-git/my-repo$ git fetch remote: Enumerating objects: 8, done. remote: Counting objects: 100% (8/8), done. remote: Compressing objects: 100% (4/4), done. remote: Total 6 (delta 1), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), 1.35 KiB | 1.35 MiB/s, done. From https://github.com/pluveto/my-repo-1 3e19b2a..176332b master -\u0026gt; origin/master 这里 git fetch 是 git fetch orgin 的缩写，后者也是 git fetch orgin/master 的缩写。\n发生了什么？orgin 是远程代码库，master 是操作的分支。执行这个命令，就是从名（alias）为 origin 的远程仓库的 master 分支拉取数据到本地代码库的 master 分支。\n然后我们执行：\npluvet@localos:~/learn-git/my-repo$ git merge Merge made by the \u0026#39;recursive\u0026#39; strategy. README.md | 3 +++ hello.txt | 2 ++ 2 files changed, 5 insertions(+) create mode 100644 README.md 将刚才下载到本地仓库的文件合并到我们的工作目录。可以观察 merge 前后的文件结构：\n发生了什么呢？git merge 是 git merge HEAD 的缩写。表示将指定的分支（HEAD，现在表示从远程下载过来的 master 分支）合并到当前的分支（本地的 master 分支）。\n 注：执行 git merge 之后，你可能会看到下面的界面：\n这是 nano 编辑器。下面两行显示了操作，^X 就表示 Ctrl+X。之所以会出现这个，是要你在里面写上 Merge 操作的原因。我们按下 Ctrl+O 保存，在出现的框中，回车确认文件名，然后 Ctrl+X 退出即可。\n 有时候我们会误操作，如何回撤 Merge 呢？执行 git reset --hard HEAD~1 即可（前面回档操作介绍过）。执行之后，merge 下来的文件也会被删除。\n现在 merge 之后，冲突已经不存在了。（其实还有一种比较麻烦的情况，就是远程和本地都同时修改了同一个文件，这个时候需要手动处理冲突，在后续章节将会说明。）\n然后，我们就可以 push 到远程仓库了：\npluvet@localos:~/learn-git/my-repo$ git push Enumerating objects: 7, done. Counting objects: 100% (7/7), done. Compressing objects: 100% (4/4), done. Writing objects: 100% (5/5), 553 bytes | 553.00 KiB/s, done. Total 5 (delta 2), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (2/2), completed with 2 local objects. To https://github.com/pluveto/my-repo-1.git 176332b..0092920 master -\u0026gt; master 新增的 undo 文件在 Github 上可以看到了：\n总结一下，我们是如何解决冲突的：\n git fetch 下载到本地仓库。 git merge 将新代码和旧代码合并。 git push 推送合并后的代码。  其中，git fetch 和 git merge 可以简写为一条指令：git pull。\n这里，我们已经初步接触了 Git 的分支的概念。下面将深入学习分支。\n分支\r#\r\r有时候，你的软件需要增加一些功能，而增加这个功能需要多次提交代码。为了不影响现有的产品，就可以建立一个分支，等开发、测试完毕了，再合并到主干。现在，让我们从一个现有的代码库开始。\n复制代码库\r#\r\r访问 incolore-team/asc-table: This repo is for learning git (github.com)，你将会看到一个现有的代码库。但是你对其没有控制权。点击右上角的 Fork：\n等待 Fork 完成：\n将会将这个仓库复制一份到你的名下：\n克隆仓库\r#\r\r现在复制到你名下的仓库，你是有控制权的。我们如何在本机上编辑这个代码库的代码呢？点击 ↓ Code 按钮，复制里面的链接：\n然后执行：\npluvet@localos:~/learn-git$ git clone https://github.com/pluveto/asc-table.git\rCloning into 'asc-table'...\rremote: Enumerating objects: 4, done.\rremote: Counting objects: 100% (4/4), done.\rremote: Compressing objects: 100% (3/3), done.\rremote: Total 4 (delta 0), reused 4 (delta 0), pack-reused 0\rUnpacking objects: 100% (4/4), 471 bytes | 471.00 KiB/s, done.\r 克隆指令：将远程代码仓库下载到本地。\ngit clone \u0026lt;url\u0026gt;\n 进入克隆下来的工作目录：\npluvet@localos:~/learn-git$ cd asc-table/ 列出文件：\npluvet@localos:~/learn-git/asc-table$ ls -al total 20 drwxrwxr-x 3 pluvet pluvet 4096 1月 24 14:39 . drwxrwxr-x 4 pluvet pluvet 4096 1月 24 14:39 .. drwxrwxr-x 8 pluvet pluvet 4096 1月 24 14:39 .git -rw-rw-r-- 1 pluvet pluvet 5 1月 24 14:39 .gitignore -rw-rw-r-- 1 pluvet pluvet 453 1月 24 14:39 program.cpp 可以看到一个 .git 目录，一个 .gitignore 文件，以及 program.cpp 文件。\n关于 .git 目录，涉及到 Git 的底层原理，感兴趣的可以阅读：Git - 底层命令与上层命令 (git-scm.com)\n.gitignore 文件表示在 git add 时忽略的文件，一般会写入一些临时文件、临时文件夹等。关于编写这个文件的规则，你可以阅读：Git - gitignore Documentation (git-scm.com)\n我们查看这个文件的内容：\npluvet@localos:~/learn-git/asc-table$ cat .gitignore a.out 里面写了 a.out ，说明忽略 a.out 这个文件。\n查看有哪些分支\r#\r\r执行：\npluvet@localos:~/learn-git/asc-table$ git branch * main 新增分支\r#\r\r执行：\npluvet@localos:~/learn-git/asc-table$ git branch br1 pluvet@localos:~/learn-git/asc-table$ git branch br1 * main 重命名分支\r#\r\rpluvet@localos:~/learn-git/asc-table$ git branch -m br1 branch_1 pluvet@localos:~/learn-git/asc-table$ git branch branch_1 * main 为当前分支重命名，则是：\npluvet@localos:~/learn-git/asc-table$ git branch -M main 参考\r#\r\rGitHub 漫游指南 – GitHub 漫游指南 (phodal.com)\nGit 与 GitHub 入门实践_Git - 蓝桥云课 (lanqiao.cn)\n手撕Git，告别盲目记忆 - 知乎 (zhihu.com)\ngit - What does \u0026lsquo;\u0026ndash;set-upstream\u0026rsquo; do? - Stack Overflow\nGit 里面的 origin 到底代表啥意思? - 知乎 (zhihu.com)\nHow To Set Upstream Branch on Git – devconnected\n创建版本库 - 廖雪峰的官方网站 (liaoxuefeng.com)\nBasic Git commands | Bitbucket Data Center and Server 7.9 | Atlassian Documentation\n"});index.add({'id':10,'href':'/posts/%E4%B8%BB%E8%A6%81%E5%8F%82%E8%80%83/','title':"主要参考",'section':"Posts",'content':"xv6\r#\r\rxv6 是 MIT 开发的一个教学用的完整的类 Unix 操作系统，并且在 MIT 的操作系统课程 6.828 中使用。通过阅读并理解 xv6 的代码，可以清楚地了解操作系统中众多核心的概念\n学习：6.828 / Fall 2012 (mit.edu)\n地址：ranxian/xv6-chinese: 中文版的 MIT xv6 文档 (github.com)\nOSDev.org\r#\r\r非常详细的操作系统开发百科全书。\n地址：OSDev.org](http://www.osdev.org/)\n"});})();